\newpage
\begin{center}
  \textbf{\large 2. ТЕХНИЧЕСКАЯ РЕАЛИЗАЦИЯ}
\end{center}
\refstepcounter{chapter}
\addcontentsline{toc}{chapter}{2. ТЕХНИЧЕСКАЯ РЕАЛИЗАЦИЯ}

\section{Описание бизнес-процессов}

Главные процессы связаны с выполнением вычислительных задач и развертыванием контейнеров, что требует ручной настройки серверной инфраструктуры и управления вычислительными ресурсами. Это обеспечивает выполнение клиентских запросов, но сопровождается значительными временными затратами и сложностями администрирования. На рисунке ~\ref{IDEF0_AS-IS} показан сам бизнес-процесс выполнения вычислительных задач и развертывания контейнеров до автоматизации, а на рисунке ~\ref{IDEF0_AS-IS_Extended} представлена декомпозиция данного процесса.

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\linewidth]{generated/IDEF0_AS-IS.drawio.png}
  \caption{Процесс выполнения вычислений на удаленном сервере}
  \label{IDEF0_AS-IS}
\end{figure*}

Среди основных проблем неавтоматизированного бизнес-процесса можно выделить:
\begin{itemize}
  \item[---]получение запросов от клиентов через ручные каналы связи, что увеличивает время на их обработку и уточнение технических требований;
  \item[---]ручное конфигурирование серверной инфраструктуры под каждую задачу, что требует значительных временных и трудовых затрат от администраторов;
  \item[---]отсутствие централизованной системы мониторинга выполнения задач, что приводит к необходимости постоянного ручного контроля и увеличению вероятности ошибок;
  \item[---]передача результатов клиентам осуществляется вручную, что замедляет процесс и увеличивает вероятность задержек.
\end{itemize}

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\linewidth]{generated/IDEF0_AS-IS_Extended.drawio.png}
  \caption{Декомпозиция процесса выполения удаленных вычислений}
  \label{IDEF0_AS-IS_Extended}
\end{figure*}

После автоматизации значительно минимизируется участие специалистов в ручной настройке серверной инфраструктуры и мониторинге выполнения задач, что упрощает и ускоряет процесс развертывания и выполнения контейнеров. На рисунке ~\ref{IDEF0_TO-BE} показан бизнес-процесс выполнения лямбда-функций после автоматизации, а на рисунке ~\ref{IDEF0_TO-BE_Extended} представлена декомпозиция данного процесса.

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\linewidth]{generated/IDEF0_TO-BE.drawio.png}
  \caption{Процесс выполнения вычислений в бессерверной среде}
  \label{IDEF0_TO-BE}
\end{figure*}

Основными преимуществами автоматизированного бизнес-процесса являются:
\begin{itemize}
  \item[---]автоматическое развертывание контейнеров с минимальным участием специалистов;
  \item[---]гибкость настройки выполнения задач благодаря удобному интерфейсу и API;
  \item[---]автоматическое формирование отчетов по выполнению задач и сбор статистики о загрузке ресурсов;
  \item[---]возможность одновременного выполнения множества задач с оптимизацией использования инфраструктуры.
\end{itemize}

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\linewidth]{generated/IDEF0_TO-BE_Extended.drawio.png}
  \caption{Декомпозиция процесса выполения вычислений в бессерверверной среде}
  \label{IDEF0_TO-BE_Extended}
\end{figure*}

\section{Описание архитектуры решения}

Описание архитектуры приложения является ключевым этапом в проектировании програмного решения. Описанная архитектура позволяет разделить систему на независимые компоненты, определить взаимосвязи между ними, правила их мастабирования а так же обеспечить согласованность в их разработке. 

Разрабатываемое приложение представляет собой моногокомпонентное клиент-серверное решение и стоит незавыисимых функциональных блоков:

\begin{itemize}
  \item[---] Серверверная часть приложения
  \item[---] Клиентская часть приложения 
\end{itemize}

Серверная часть в свою очередь состоит из таких компонентов как:

\begin{itemize}
  \item[---] Reverse proxy\cite{sommerlad2003reverse};
  \item[---] Internal API Gateway
  \item[---] External API Gateway
  \item[---] Сревер авторизации
  \item[---] Брокер сообщений
  \item[---] СУБД
  \item[---] Слой платформенных сервисов
  \item[---] Подчиненный кластер Kubernetes
\end{itemize}

На рисунке ~\ref{SystemDiagram} представлена схема взаимодействия и размещения компонентов системы.

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\linewidth]{generated/SystemDiagram.drawio.png}
  \caption{Компоненты плфтормы}
  \label{SystemDiagram}
\end{figure*}

\subsection{Среда развертывания}

Сейчас на рынке существует несколько подходов к развертыванию сервисов. Каждая из представленных сред имеет свои плюсы и минусы.

{\bf Физические серверы}

В настоящее время развертывание веб-сервисов на физических серверах является устаревшим подходом. Такой подход имеет большое число минусов, таких как необходимость управления зависимостями разворачиваемых сервосов, сложности с масштабированием.

{\bf Виртуальные машины}

Вируальные машины позволяют запускать сервисы в изолированных вируальных средах, хорошо масштабируются но требуют ручного управления ресурсами, сильно уступают контейнерным решениям по эффективности использования ресусов и чаще всего исопльзуются для узкоспециализироанных сервисов.

{\bf Контейнеры без оркестрации}

Развертывание в контейнерах без оркестрации хорошо подходит для разворачивания небольших сервисов а так же для локального запуска, но при использовании в промышленных средах требование ручного управления контейнерами делает такие системы неприменимыми.

{\bf Контейнерные оркестраторы}

Контейнерные оркестраторы предоставляют возможность объединения нескольких физических серверов в один кластер с едиными ресурсами, таким образом осуществляется удиное эффективное управление всеми ресурсами системы, достигается ее масштабируемость и отказоустойчивость. 

{\bf Выбор оркестратора}

Для разворачивания разрабатываемой платформы оптимальным выбором является Kubernets, так как он обеспечивает гибкое и эффективное управление ресурсами клстера при помощи yaml манифестов и является стандартом в индустрии для выполнения задач оркестрации контейнеров.

\subsection{Reverse proxy}

Размещение веб-сервера или сервера приложений непосредственно в Интернете дает злоумышленникам прямой доступ к любым уязвимостям базовой платформы (приложения, веб-сервера, библиотек, операционной системы). Для того что бы избежать появления такого рода уязвимостей широко распространен паттер Reverse-proxy\cite{sommerlad2003reverse}.

Reverse-proxy представляет собой промежуточный слой между внутренними сервисами приложения и внешними клиентами.
Так же веб-сервер, выступающий в роли reverse-proxy может выолнять следующие функции:

\begin{itemize}
  \item[---] Маршрутизация запросов;
  \item[---] Балансировка нагрузки;
  \item[---] SSl-терминация;
  \item[---] Фильтрация запросов;
  \item[---] Кеширование;
  \item[---] Сжатие контента;
  \item[---] Управление статическими ресурсами. 
\end{itemize}

В качестве reverse-proxy для реализации платформы был выбран веб-сервер nginx. Этот компонент будет отвечать за SSL-терминацию и раздачу статического контента.

\subsection{Ingress, Egress}

В качестве реализацией для Internal Api Gateway(IAG) и External Api Gateway(EAG) выбраны соотвествующие реализации Istio Ingress и Egress.

Главная задача которую выполняет IAG - распределение входящего трафика по репликам сервисов для обеспечения равномерного и эффективного использования ресурсов.

В то же время EAG отвечает за маршрутизацию исходящего трафика. Он служит точкой выхода трафика, направленного на получение внешних ресурсов.

\subsection{Сревер авторизации}

Сервер авторизации в плфторме отвечает за авторизацию и аутентификацию пользователей, а так же запросов от входящих интеграций, выполняет централизованное управление доступом к сервисам платформы. 

К возможным реализациям сервера авторизации можно отнести такие сервисы как:

Среди бошаого колличества реализаций сервера авторизации для платформы выбран сервис Keycloak. Keycloak по сравнению с конкурентами обладает следующими преимуществами:

\begin{itemize}
  \item[---] Решение с открытым исходным кодом;
  \item[---] Поддержка большого колличество протоколов авторизации и SSO;
  \item[---] Наличие системы управления польователями и ролями;
  \item[---] Нативная интеграция с Kubernetes и масштабируемость;
  \item[---] Возможность локального развертывания;
  \item[---] Подержка СУБД PostgresSQL;
  \item[---] Наличие Java клиента;
  \item[---] Наличие адаптера Spring Sequrity;
  \item[---] Наличие административной панели. 
\end{itemize}

\subsection{Брокер сообщений}

Брокер сообщений это промежуточное звено в системе. Он обеспечивает асинхронное возаимодействие между компонентами системы. Основаная задача которую выполняет брокер сообщений - позволяет не дожидаться выполнения ресурсоемких операций и получить результат их выполнения асинхронно позже. 

Брокеры сообщений играют ключевую роль в реализации таких системных паттернов как очередь сообщений\cite{raje2019performance}, Saga\cite{durr2021evaluation}, а так же целого семейства Enterprise Integration Pattern (EIP)\cite{hohpe2004enterprise}.

На данный момент основными реализациями брокера сообщений представленными на рынке являются:

\begin{itemize}
  \item[---] Apache Kafka;
  \item[---] RabbitMQ;
  \item[---] ActiveMQ;
  \item[---] Redis Streams.
\end{itemize}

В качестве основого брокера сообщений на платформе выбран брокер сообщений Apache Kafka.
К основным плюсам по сравнению с другими реализациями брокеров можно отнести концептуальное отличие данного брокера отдругих представленным на рынке.

Kafka поррерживает многокартное потребление сообщений, делая возможными сценарии использования Kafka в качестве Enterprise Service Bus\cite{menge2007enterprise} и позволяет не терять сообщения при ошибках и прерываниях обработки.

Так же в преимуществам выбора брокера сообщений Kafka можно отнести:

\begin{itemize}
  \item[---] Масштабируемость и производительность;
  \item[---] Высокая доступность и отказоустойчивость;
  \item[---] Поддержка потоковой обработки;
  \item[---] Гибкость интеграции;
  \item[---] Интеграция с Kubernetes;
  \item[---] Обширная экосистема и поддержка сообщества.
\end{itemize}

\subsection{СУБД}

В проектируемой системе база данных неодходима для хранения у управления пользовательскими данными. Система управления базой данных(СУБД) обеспечивает эффективную организацию данных, в отдельных случаях транзакционность, целостность и надежность. СУБД так же предоставляет возможности масштабирования и интеграций с другими системами.

Все СУБД можно разделить на две группы по способу организации данных - реляционные и нереляционные. Главное отличие реляционных баз данных от нереляционных заключается в использовании реляционными базами данных таблиц с фиксированной схемой для хранения данных и поддержка строгих отношений между таблицами с использованием внешних ключей, в то время как нереляционные базы данных являются более гибкими и хранят данные в формате ключ - занчение и не продъявля/т каких либо требований к схеме хранимых данных.

Данные, хранимые платформой сильно структурированы и для выполнения бизнесс логики приложения критична их целостность, поэтому единственным верным выбором будет реляционная СУБД. На данный момент на рынке представлены следующие сервисы:

\begin{itemize}
  \item[---] PostgreSQL;
  \item[---] MySQL;
  \item[---] Oracle Database;
  \item[---] MariaDB.
\end{itemize}

Для исполновании в реализации платформы выбрана СУБД PostgreSQL по следующим причинам:

\begin{itemize}
  \item[---] Поддержка сложных типов данных, возможность расширения встроенных типов данных;
  \item[---] Поддержка транзакций;
  \item[---] Открытый исходный код и активное сообщество;
  \item[---] Масштабируемость и отказоустойчивость.
\end{itemize}

\subsection{Слой платформенных сервисов}

Слой платформенных сервисов играет ключевую роль в системе, так как именно он отвечает за функциональные возможности системы, управление процессами выполнения вычислений.

На данный момент существует два конкурируюзих подхода к организации сервсов приложений - монолит и микросервисы\cite{newman2019monolith}.

{\bf Монолитная архитектура}

Монолитный сервис представляет собой единую единицу развертывания которая отвечает за все функции системы. При использовании такого подхода на начальных этапах можно добиться быстрого вывода на рынок основного функционала, но при длительной разработке и с использованием монолитной архтектуры можно столкнуться с проблемами со сложностью внесения изменений, увеличеии времени холодного старта, увеличением времени проходжения конвеера доставки и развертывания а так же с увеличенным расходом ресурсов при масштабировании и возможными периоднами недоступности при развертыании или неожданных отказах.

{\bf Микросервисная архитектура}

Главная идея микросервисной архитектуры заключается в разделении системы на отдельные независимые подсистемы - микросервисы. Каждый микросервис должен отвечать за свою небольшую часть функционала.

Основыным преимуществом использования микросервисов является возможность независимого развертывания и прохожения конвеера доставки и развертывания. Микросервысы могут масштабироваться независимо, позваоля добавлять реплики нагруженным сервисам во время пиковых перидов нагрузки, а малонагруженные сервисы разворачивать с малым колличеством реплик.

Использование микросервисной архитектуры усложняет внесение изменений в существующую систему, а так же требует более сложного управления инфраструктурой.
При использовании микросервисной архитектуры появляется необхзодимость в сохранении обратной совместимости между версиями сервисов, так как при установке поставки на стенде может находиться одновременно старая и новая версия сервиса для поддржки плавной незамтной для пользователя раскатки.
Использвоание микросервисосв так же увеличивает время отклика сервисов, так как возникают дополнительные накладные расходы при выполнении межсервисных вызовов, так же при отказе отдельных сервисов могут возникат тредности с локализацией проблемы, что приводит к необзодимости внедрения распределенный трассировки вызовов.

{\bf Выбор архитектуры сервисного слоя}

Для сервисного слоя платформы выбрана  монолитная архитектура, при этом необходимо осуществлять проектирование функционала так, что бы в последствие он мог быть отделен в отдельные сервисы. При разработке важно соблюдать слабую связанность\cite{valipour2009brief} между сервисами, используя такие подходы как Domain Driven Design(DDD) \cite{evans2004domain} или Verical Slice\cite{ratner2011vertical}

\subsection{Подчиненный кластер Kubernetes}

Подчиненный кластер Kubernetes в системе предназначен для разворачивания в нем задач, создаваемых пользователями. Он является выделенной изолированный средой которая обеспечивает гибкость, масштабируемость и отказоустойчивость системы.

\section{Обоснование технологического стека}

\subsection{Клиенская часть}

При разработке клиенской части приложения использован fontend фреймворк Vue3.
Для управления состоянием клиентского приложения испольована библиотука Pinia.
Для работы со стилизаций компонентов интерфейса использованы библиотки TailwindCSS и DaisyUI.

Такой стек технологий позволяет эффективно выполнять задачи, поставленные перед разработкой клиентской части.
Фреймворк Vue3 обладает полее высокой производительностью по сравнению с предыдущей версией Vue2 и аналогами React и Angurlar.

Так же Vue3 более удобен для разработки и имеет более низкий порог вхождения. Поддрежка TypeScript позволят разрабатывать более надежные и предсказуемые компоненты.

Менеджер управления состоянием приложения Pinia выбран так как является официальной заменой Vuex в Vue3. По сравнению с предшественником новый стейтменеджер более простой и понятный так как в нет мутаций и он по умолчанию поддерживает реактивность, которая пришла на смену CompositionAPI в новой версии фреймворка.

TailwindCSS это библиотека позволяюзая избежать работы со стилями компонентов напрямую. Благодаря гибкой системе заранее предопределенных классов библиотека позволяет сократить дублирование кода и ускорить разработку.

DaisyUI является самой большой и популярной библиотекой UI компонентов постоенной на TailwindCSS. Она предлагает большой набор компонентов и тем для приложения которые гибко интегрируются с остальной системой по средствам применения классов к HTML-тегам.

\subsection{Серверная часть}

Для разработки серверной части платформы выбран язые программиования Kotlin, этот язык относится к семейству языков компилирующихся в байткод поддерживаемый виртуальной машиной Java. Для разработки так же выбрана версия Java 21 так как она является самой последней версией языка для которой на момент написания работы заявлена длинтельня поддержка (LTS).

По сравнению с Java, Kotlin имеет более выразительный синтаксис и является более безопасным так как частью языка являются механимзмы защиты от разименования $null$ указателей\cite{samuel2017programming}.

Фреймворком для написания серверной чати приложения выбран Spring и Spring Boot.
Данное решение является стандартом в отрасти и зарекомандовало как себя удобное и эффективное для построения такого рода систем.

Экосистема Spring обладает большим колличеством библиотек позволяющими расширить функционал фемворка и интегрироваться с большинством сторонних систем.
Для разработки серверной части платформы с состав дистрибутива были включены следующие библиотеки:

\begin{itemize}
  \item[---] keycloak-admin-client --- для интеграции системы с сервером авторизации Keycloak через REST API;
  \item[---] spring-data-jdbc --- для интеграции с СУБД PostgreSQL;
  \item[---] kubernetes-client-java --- для интеграции системы с подчиненным кластером Kubernetes;
  \item[---] spring-security --- для обработки авторизационных токенов и создание политик доступа к предоставляемым сервисам.
\end{itemize}

Для сборки серверной касти приложения выбрана система автоматической сборки Gradle, так как она является современной заменой устаревший системе сборки Maven, дает более гибкий и удобный инструментарий, а так же на момент написания работы является стандартом в отрасли. 

\section{Разработка модели данных}

На платформе используется две базы данных - одна из них используется для хранения данных проектируемого сервиса, вторая - для хранения данных сервера авторизации.

\subsection{Модель базы данных сервиса}

В рамках предметной области основными сущностями являются пользователь, группа пользователей задача, результат выполнения задачи.

На рисунке ~\ref{DatabaseDiagram} ER диаграмма, на которой изображены сущности базы данных и взаимосвязи между ними.

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\linewidth]{generated/database-diagram.png}
  \caption{Диаграмма отношений таблиц базы данных}
  \label{DatabaseDiagram}
\end{figure*}

В модели базы данных испльзуется подход по реализации перечислений (enumirations) с использованием референсных таблиц, в которых первичным ключом является колонка $name$, на которую ссылаются таблицы исполуьзующие значения из данной таблицы в качестве перечислений.
Колонка $description$ при этом является справочной и служит только для хранения человекочитаемого описания значения перечисления.

К референсным относятся таблицы $job\_statuses$, $execution\_statuses$, \linebreak $execution\_types$ которые хранят статусы задач и запусков.

Таблица $jobs$ является центральной таблицу для хранения информации о запущенных задачах. Статусом задачи является одно из значений поля $name$ референсной таблицы $job\_statuses$.
Время создания записи в таблицу фиксирутся автоматически а поле $created\_at$.

Таблица $jobs$ имеет сдедующие поля:

\begin{itemize}
  \item[---]$id$ --- $bigint$ — Уникальный идентификатор задачи.
  \item[---]$user\_id$ --- $uuid$ —-- Идентификатор пользователя, создавшего задачу.
  \item[---]$name$ --- $varchar(255)$ — Имя задачи.
  \item[---]$created\_at$ --- $timestamp$ — Время создания задачи.
  \item[---]$docker_image$ --- $varchar(1024)$ — Docker-образ, который используется для выполнения задачи.
  \item[---]$command$ --- $text$ — Команда или скрипт, который выполняется в рамках задачи.
  \item[---]$environment_variables$ --- $text$ — Переменные окружения, используемые для выполнения задачи.
  \item[---]$execution_type$ --- $varchar$ — Тип выполнения задачи;
  \item[---]$schedule$ --- $varchar(255)$ — Расписание выполнения задачи (cron-выражение).
  \item[---]$status$ --- $varchar(50)$ — Статус задачи.
  \item[---]$ordinal$ --- $integer$ — Порядковый номер задачи.
  \item[---]$deleted$ --- $boolean$ — Флаг, показывающий, удалена ли задача.
\end{itemize}

Результаты выполнения задач располагаются в таблице $execution\_result$. Для создания отношения один ко многим с таблицей $job\_statuses$, внешним ключем является поле $job\_id$.

Таблица $execution\_result$ имеет сдедующие поля:

\begin{itemize}
  \item[---]$id$ --- $integer$ — Уникальный идентификатор результата выполнения.
  \item[---]$job\_id$ --- $bigint$ — Идентификатор задачи, к которой привязан результат. 
  \item[---]$started\_at$ --- $timestamp$ — Время начала выполнения задачи.
  \item[---]$finished\_at$ --- $timestamp$ — Время завершения задачи.
  \item[---]$status$ --- $varchar$ — Статус выполнения задачи.
  \item[---]$logs$ --- $text$ — Массив логов, связанных с выполнением задачи.
  \item[---]$exit\_code$ --- $integer$ — Код завершения выполнения задачи.
  \item[---]$error\_message$ --- $text$ — Сообщение об ошибке.
  \item[---]$recorded_at$ --- $timestamp$ — Время записи результата выполнения.
  \item[---]$original\_job\_name$ --- $varchar$ — Оригинальное имя задачи.
\end{itemize}

Таблица $users$ хранит данные дублирующие информацию о зарегистрированных пользователях, хранящаюся на сервере авторизации. Она необходима для содния внешних ключей в которых значением является идентификатор пользователя в системе авторизации.

\subsection{Модель базы данных сервера авторизации}

Модель базы данных сервера авторизации играет важную роль в работе системы, так как информация о пользователях, а так же их положение в ролевой модели хранится на сервере авторизации.

Ключевыми сущностями хранения информации о пользователях являются пользователь, атрибут пользователя, группа, роль. ER диаграмма чати сервера авторизации по работе с данными пользователей и ролевой моделью представлена на рисунке ~\ref{KeyclaokDatabaseDiagram}.

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\linewidth]{generated/keycloak-user-information-database-diagram.drawio.png}
  \caption{Модель хранения данных пользователей на сервере авторизации}
  \label{KeyclaokDatabaseDiagram}
\end{figure*}

Таблица $user\_entity$ отвечает за хранение позовой информации об учетной записи. Первичным идентификатором таблицы является идентификатор пользователя, через который происходит связыване со всеми остальными таблицами, отвечающими за хранение пользовательскиих данных. Она включает в себя такие поля как:

\begin{itemize}
  \item[---]$id$ --- Идентифкатор пользователя;
  \item[---]$email$ --- Элекстронная почта;
  \item[---]$email\_verified$ --- Признак подтверждения почты;
  \item[---]$enabled$ --- Признак активности учетной записи;
  \item[---]$first\_name$ --- Имя;
  \item[---]$last\_name$ --- Фамилия;
  \item[---]$realm\_id$ --- Идентификатор тенанта пользователя;
  \item[---]$username$ --- Имя пользователя;
  \item[---]$created\_timestamp$ --- Время создания учетной записи;
\end{itemize}

Пользователям можно добавлять произвольные атрибуты, которые хранятся в таблицу $user\_atrribute$.

Пароли пользователей хранятся в таблице $credetial$ в хешированном виде. Такой подход к хранению паролей пользователей является безопасным, так как хеш пароля невозможно однозначно преобразовать в пароль.

В таблице $keycloak\_role$ хранится информация о ролях пользователей, существующих в системе. К роли  можно добавлять произвольные атрибуты, которые хранятся в таблице $role\_attribute$.

Сервер авторизации поддерживает созадние композитных ролей, путем связывания нескольких ролей с одной, родительской ролью. Связывание происходит серез таблицу $composite\_role$.

Роли могут быть связаны с пользователем через отношение многие ко многим, которые реализовано через третью таблицу $user\_role\_mapping$.

Более предпочтительным способ связывания пользователей с ролями является использование межанизма групп пользователей, который позволяет создать статический маппинг наборов ролей на пользователей системы, на основании их принадлежности той или иной группе.

В таблице $keycloak\_group$ хранится информация о группах пользователей. К группе пользователей можно добавлять произвольные атрибуты, которые хранятся в таблице $group\_attribute$. Группы могут быть организованы в иерархическую структуру, что позволяет выстривать сложные ролевые модели.

К группе может быть присвоено несколько ролей, при помощи связывания многие ко многим через таблицу $group\_role\_mapping$. При связывании групп в иерархическую структуру пользоватль наследует все роли родительских групп в которых находится.

Пользователи и группы пользователей связаны отношением многие ко многим --- пользователи могут состоять в нескольких группах и в одной группе может состоять несколько пользователей. Для релизации такого подхода используется связывание через третью таблицу $user\_group\_membership$.

\section{Разработка ролевой модели}

Ролевая модель плфтормы реализована на механизмах управления ролями и группами Keycloak. Объединение пользователей в группы позволяет организовать соместное управление выполением задач.

\subsection{Создание группы}

Группа пользователей может быть создана пользователем на странице профиля пользователя. При создании группы, пользователь становится ее администратором.

Так как группы не опрелены заранее и создаются пользователями в процессе использования плфтформы в названии группы должна присутствовать генерерируемая компонента, гарантирующая уникальность идентивикатора группы, так же необзодимо предусмотреть возможность воода имени группы пользователем.

Для того что бы соблюсти все заявленные к имени группы требованиям идентфиикатором группы является случайный UUID идентифкатор. Для того что бы сохранить пользовательское название группы, создаятся атрибут группы с ее названием.

\subsection{Создание ролей в рамках группы}

Для каждой группы создаются роли, соответствующие необходимым уровням доступа к различным частям функционала платформы.

Идентфикатором роли так же будет являться UUID идентфикатор, гарантирующий уникальность, имя роли сохраняется атрибутом $name$.

В системе в рамках группы существуют следующие уровни доступа:

\begin{itemize}
  \item[---]$VIEW$ --– просмотр задач, созданных в группе.
  \item[---]$EDIT$ –-- изменение параметров запущенных задач, их остановка и удаление.
  \item[---]$RUN$ –-- создание новых задач.
  \item[---]$ADMIN$ –-- управление группой (добавление и удаление участников, назначение ролей, генерация токенов доступа).
\end{itemize}

\section{Разработка каркасных макетов пользовательского итерфейса}

\subsection{Неавторизованная зона}

Страница неавторизованой зоны предназначена для неавторизованных пользователей. Данные страница выполняет функции:

\begin{itemize}
  \item[---] проедоставляет преход на траницу входа и регистрации;
  \item[---] знакомит пользователя с функционалом платформы;
  \item[---] отображает новости и правочную информацию;
  \item[---] предоставляет ссылки на внешние ресурсы.
\end{itemize}

Карскасный макет страницы неавторизованой зоны представлен на рисунке ~\ref{Landing-page}.

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\linewidth]{generated/Landing-page.png}
  \caption{Каркасный макет страницы неавторизованой зоны}
  \label{Landing-page}
\end{figure*}

\subsection{Страница входа и регистрации}

Страница входа и регистрации позволяет пользователям авторизоваться или создать новый аккаунт. Форма входа представлена на каркасном макете на рисунке ~\ref{Login-page}.

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\linewidth]{generated/Login-page.png}
  \caption{Каркасный макет страницы входа}
  \label{Login-page}
\end{figure*}

Для пользователей не имеющих учетной записи в системе, предстусмотре форма регистрации, которя доступная при переходе по ссылке, находящейся в нижней части формы входа. (Рис. ~\ref{Registration-page})

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\linewidth]{generated/Registration-page.png}
  \caption{Каркасный макет страницы регистрации пользователя}
  \label{Registration-page}
\end{figure*}

\subsection{Страница запущенных задач}

На странице запущенных задач располагается информация обо всех запущенных пользователем задачах (Рис. ~\ref{Jobs-dashboard}).

В верхней части страницы располагается счетчик всех, выполненных, запущенных задач и задач запущенных неудачно.
При нажатии накаждый из счетчиков применяется соответствующий фильтр к спску задач расположенному ниже.

При взаимодействии с каким либо из элементов задач, расположенных в списке задач, пользователь переходит на стриницу задачи.

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\linewidth]{generated/Jobs-dashboard.png}
  \caption{Каркасный макет страницы запущенных задач}
  \label{Jobs-dashboard}
\end{figure*}

\subsection{Страница задачи}

На странице задачи располгается вся информация о задаче.

В Верхней части страницу расположены кнопки редактирования задачи, каоторая позволяет отредактировать параметры запуска задачи для будущих щапусков, и кнопка удаления задачи которая позволяет прекратить выполнение последующих запусков и скрыть от пользователей удаленную задачу.

В нижней части страницы располагается список запусков задачи. Если зажача запущена в данный момент отображается кнопка завершения выполнения. При взаимодействии с каким либо из элементов в списке запусков пользователь переходит на страницу запуска задачи.

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\linewidth]{generated/Task-page.png}
  \caption{Каркасный макет страницы просмотра запущенной задачи}
  \label{Task-page}
\end{figure*}

На страницу запуска задачи отображается название задачи к которой относится запуск и порядковый номер запуска, кнопки выгрузки логов запуска, завершения выполнения запуска и логи выполнения. 

Окно просмотра логов продествляет собой зону просмотра текста с прокртку по осям X и Y.

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\linewidth]{generated/Execution-page.png}
  \caption{Каркасный макет страницы просмотра запуска задачи}
  \label{Execution-page}
\end{figure*}

\subsection{Страница профиля пользователя}

На страницу профиля пользователя отображается информация о пользователе и о группах пользователей в которых он состоит.

Если пользователь состоит из какой либо группе ему отображется кнопка выхода из группы.

Если пользователь является членом группы администраторов, ему доступна форма генерации и копирования токена доступа в рабочее пространство группы.

В нижней части страницы отображается список участников группы.

Если пользователь является членом группы администраторов, ему доступно управление правами доступа дургих членов группы. Иначе чекбоксы находятся в неактивном состоянии.

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\linewidth]{generated/Profile-page.png}
  \caption{Каркасный макет сраницы }
  \label{Profile-page}
\end{figure*}

\section{Разработка програмного интерфейса сервеной чаcти}

\subsection{Назначение и роль API в системе}

Прикладной прграммный интерфейс (API) \cite{ong2015materials} серверной части системы выступает ключевым элементом архитектуры, обеспечивая возаимодействие между киентами и сервисами разрабатываемой системы.

API в системе выполняет такие такие функции как:

\begin{itemize}
  \item[---] служит единой точной входят для всех клиентов;
  \item[---] предосталяет единый способ взаимодействия с системой.
\end{itemize}

Основными потребителями програмного интерфейса разрабатываемого серверного решение является веб-клиент платформы, а так же потребители webhook\cite{biehl2017webhooks} сервисов, предоставляемых платформой.

\subsection{Выбор архитектурного стиля прикладного программного интерфейса}

При проектировании серверной части критически важен выбор подхода и врхитектуры проектирования API.
Этот выбор определяет подходы взаимодействия между клиентом и сервером, а так же влияет на поизводительность, масштабируемость и простоту интеграции с разрабатываемым сервисом.
В настоящее время в проектировании API наиболее распространены 3 подхода: 

\begin{itemize}
  \item[---] REST\cite{wilde2011rest};
  \item[---] SOAP\cite{box2000simple};
  \item[---] Различные RPC протоколы\cite{srinivasan1995rpc}. 
\end{itemize}

В качестве архитектурного подхода к проектированию программного интерфейса выбран Representational State Transfer (REST).

Ключевыми аспектами в выборе REST как архитектурного подхода к проектированию программного инерфейса стали:

\begin{itemize}
  \item[---] широкое распространение и поддержка: rest является отраслевым стандартом при проектировании веб-API;
  \item[---] использование стандартных протоколов HTTP/HTTPS;
  \item[---] простота интеграции;
  \item[---] использоваение текстового кодирования данных: упрощает и ускоряет отладку. 
\end{itemize}

\subsection{Основные ресурсы и логические группы конечных точек}

Прикладной программный инерфейс платформы предусмотривает набор операций, позволяющих клиентам управлять ресурсами платформы.
К основыным ресурсам плфтормы можно онести:

\begin{itemize}
  \item[---] JwtToken - ресурс, представляющий набор данных, содержащих криптографические токены, необходимые для взаимодействия с конечными точками, защищенными механизмами авторизации;
  \item[---] User - ресурс, представляющий набор данных о пользователе, в том числе информацию о пользователе, о его ролях и группах в которых он состоит;
  \item[---] GroupDescription - ресурс, представляющий группу пользователей;
  \item[---] Permission - доступ к той или иной части функционала платформы в рамках группы пользователей и разделенных между ними ресурсами; 
  \item[---] Job - ресурс, представляющий информацию о задаче, включает все параметры выполнения задачи, а так же информацию о ее запусках;
  \item[---] ExecutionResult - ресурс, представляющий информацию о запуске задачи. 
\end{itemize}

Логически все конечные точки программного интерфейса системы можно разделить по различным наборам признаков: по доступности из неавторизованной зоны, по ресурсу, к которому конечная точка позволяет получить доступ, по наличию вляния на состояние системы.

Из неавторизованой зоны доступны только конечные точки, позволяющие польюзователю зарегистрироваться, пройти авторизацию или сбросить пароль.
К этой группе конечных точек относятся:

\begin{itemize}
  \item[---] POST /public/api/v1/authentication/reset-password;
  \item[---] POST /public/api/v1/authentication/log-in;
  \item[---] POST /public/api/v1/registration;
\end{itemize}

Все остальные конечные точки доступны только из авторизованой зоны.

По ресурсу, к которому контрольная точка предоставляет доступ конечные точки можно разделить на группы:

\begin{itemize}
  \item[---] Управление пользователями;
  \item[---] Управление групповым досутпом;
  \item[---] Управление запущенными задачами;
\end{itemize}

К группе конечных точек, позволяющих управлять пользователями относятся конечные точыеи доступные из неавторизованой зоны.

К группе конечных точек, позволяющих управлять групповым доступом польхователей относятся конечные точки:

\begin{itemize}
  \item[---] POST /api/v1/role-model/refresh-join-group-token/{groupId};
  \item[---] POST /api/v1/role-model/leave-group/{groupId};
  \item[---] POST /api/v1/role-model/join-group;
  \item[---] POST /api/v1/role-model/exclude-member-from-group;
  \item[---] POST /api/v1/role-model/create-group;
  \item[---] POST /api/v1/role-model/change-permission;
  \item[---] GET /api/v1/role-model/group/{groupId};
  \item[---] GET /api/v1/role-model/get-join-group-token/{groupId}.
\end{itemize}

К группе конечных точек, позволяюших управлять запущенными задачами относятся:

\begin{itemize}
  \item[---] GET /api/v1/job
  \item[---] POST /api/v1/job
  \item[---] POST /api/v1/job/webhook/run/{id}
  \item[---] POST /api/v1/job/rerun/{id}
  \item[---] POST /api/v1/job/delete/{id}
  \item[---] POST /api/v1/job/cancel/{id}
  \item[---] GET /api/v1/job/{id}
\end{itemize}

К группе конечных точек, позволяющих менять состояние ресурсов системы относятся все конечные точки использующие метод пост при выполнении http зпроса.

\subsection{Описание сценариев использования}

В системе предсумотрены различные сценарии использования API для выполнения задач управления удаленными вычислениями через плфторму.

К основным сценариям можно отнести:

\begin{itemize}
  \item[---] Авторизация пользователя;
  \item[---] Создание новой группы пользователей;
  \item[---] Добавление пользователя в группу;
  \item[---] Исключение пользователя из группы;
  \item[---] Добавление, отнимание доступов пользователя в рамках группы;
  \item[---] Просмотр списка участников группы и из доступов;
  \item[---] Получение списка запущенных задач и просмотр результатов выполнения;
  \item[---] Создвние новой задачи;
  \item[---] Перезапуск, остановка, удаление задачи.
\end{itemize}

{\bf Авторизация пользователя }

Пользователь может пройти авторизацию вызвав конечную точку POST /public/api/v1/authentication/log-in.

Если пользователь не имеет учетной записи в системе он может ее создать вызвав конечную точку POST /public/api/v1/registration.

Ответом сервера при входе и регистрации будет пара Jwt токенов\cite{ahmed2019authentication}, которые пользователь должен использовать для доступа к конечным точкам защещиенным механизмами авторизации.

Если пользователь уже имеет учетную запись, но забыл от нее пароль, он может его сбросить, при вызове эндпоинта reset-password.

{\bf Сценарии управления группами пользователей }

Групповая модель доступа к ресурсам разрабатываемой системы предполагает гибкую систему групп и доступов, позволяющую разграничивать доступ к ресурсам платформы у различных пользоватлей.

По умолчанию пользователь не состоит ни в какой группе и может создавать и просматривать задачи только от своего имени.

Для того что бы создать группу пользователей необходимо вызвать конечную точку POST /api/v1/role-model/create-group. Пользователь, создавший группу, будет назначен ее администратором, а так же ему будут присвоены все дуступы в рамках созданной группы.

Для того что бы добавиьт пользователя в группу предусмотрен механизм токенов доступа в группу.
Администратор группы может запросиьт токен доступа вызвав конечную точку GET /api/v1/role-model/get-join-group-token.
Дальше токен любым удобным способ отправляется пользователю который должен вступить в группу.

Что бы присоединиться к группе необходимо вызвать конечную точку POST /api/v1/role-model/join-group.
Пользователь будет добвален в группу с доступом на просмотр по умолчанию.
Для того что бы расширить перечень доступов пользователя в рамках группы, администратор группы должен произвети соответсвующие операции.

Для добаления или удаления доступа у пользователя, являющегося членом группы, администратор должен воспользоваться конечной точкой POST /api/v1/role-model/change-permission.

Пользователь может покинуть группу используя конечную точку POST /api/v1/role-model/leave-group/\{groupId\}.

Администратор так же может исключить пользователя из группы используя конечную точку POST /api/v1/role-model/exclude-member-from-group.

{\bf Просмотр, создание и управление запущенными задачами }

Пользователь может создать задачу доступную только ему или членам группы по его выбору вызвав эндпоинт POST /api/v1/job.

Запросить список текущих задач можно вызвав эндпоинт GET /api/v1/job.

В зависимости от членства в различных группах и наличия соответствующих доступов у пользователя, при запросе текущих задач он получит список задач доступных ему или члеам группы в которую он входит и имеет доступ на просмотр.

Отдельную задачу можно получить вызвав эндпоинт GET /api/v1/job/{id}.

При наличии досупа пользовать может перезапустить задачи при помощи эндпоинта POST /api/v1/job/rerun/{id}, отменить выполнение задачи POST /api/v1/job/cancel/{id} или удалить задачу POST /api/v1/job/delete/{id}.

Если задача является веб-хуком, то пользватель может его вызвать через интерфейс или API плфтформы возмользовавшись конечной точкой POST /api/v1/job/webhook/run/{id}.

\section{Разработка сервеной части}

\subsection{Архитектура серверной части}

Серверная часть система является распределенным приложеним, в котором монолитное веб приложение служит связующим компонентом между другими частями системы.
Основу системы соствляет веб-приложение, написанное на языке Kotlin и фреймворке для написания веб-приложений Spring Boot.

Помимо разрабатываемого приложения ключевыми компонентами системы являются кластер Kubernetes, в котором разворачиваются сервисы платформы и пользовательские задачи, база данных PostgreSQL, выполняющая функции хранения данных веб-прложения и сервера авторизации, а так же сервер авторизации Keycloak, выполнязий задачи упроавления токенами доступа пользователей и хранения информации о ролях и доступах пользователей.

\subsection{Реализация REST API}

REST API платформы спроетирован в соответсвие с подходами ресурс-ориентированной архитектуры(ROA)\cite{guinard2011internet} и использует стандарт OpenAPI 3.0 для описания конечных точек.

Конечные точки платформы сгруппированы по функциональным областям - регистрация и авторизация, управление групповым доступом, управление жизненным циклом задач.

Версионирование приклодного инфтерфейса плфтформы осуществляется путем досбавления префикса v1 перед названием группы конечных точек, таким образом при дальнейшем развитии платформы, при отсутствии обратной совместимоти могут безопасно эволюционировать.

Система авторизации разрабатываемой системы использует протокол OAuth 2.0\cite{boyd2012getting} для авторизации пользователей.
За генерацию и валидацию JWT-токенов\cite{ahmed2019authentication} отвечает сервер авторизации Keycloak.

Механизмы авторизации, основанные на использовании JSON Web Token передают данные о пользователе в незашифрованном виде.

Каждый JWT токен состит из трех частей:

\begin{itemize}
  \item[---] заголовок - содержит название алгоритма подписи токена;
  \item[---] полезная нагрузка(payload) - набор утверждений(claims) о пользователе;
  \item[---] подпись токена - HMAC-хэш, вычисленный сервром авторизации с использованием приватного ключа.
\end{itemize}

Полезная так как JWT-токен передает полезную нагрузку в незашифрованном виде, утверждения о пользователе не должны содержать какой либо чувствительной информации.
Подмена утверждений содержащихся в токене невозможна так как при изменении набора утверждений, неизбежно изменится их хеш, содержащийся в последней части токена и вычисляемый с использованием приватного ключа, который известен только серверу авторизации. Таким образом гарантируется безопасность доступа к ресурсом платформы.

Here is a reference to the code listing \ref{lst:example}.

\begin{lstlisting}[caption={Hello World in Python}, label=lst:example]
def hello_world():
    print("Hello, World!")
    
hello_world()

@Service
class KubernetesService 

    private val apiClient: ApiClient = Config.defaultClient()
    private val coreApi: CoreV1Api = CoreV1Api(apiClient)
    private val batchApi: BatchV1Api = BatchV1Api(apiClient)

    fun startJob(jobParameters: JobParameters) {
        V1JobFactory.createV1Job(jobParameters)
            .also { logger.info("Job created $it") }
            .let {
                batchApi.createNamespacedJob(ORCHESTRATION_NAMESPACE, it)
                    .pretty("true")
                    .execute()
            }
    }

    fun startCronJob(jobParameters: JobParameters) {
        V1JobFactory.createV1CronJob(jobParameters)
            .also { logger.info("Cron Job created $it") }
            .let {
                batchApi.createNamespacedCronJob(ORCHESTRATION_NAMESPACE, it)
                    .pretty("true")
                    .execute()
            }
    }
\end{lstlisting}

При проектировании авторизации платформы, критическим требованием была реализация платформы без редиректов, из-за этого было принято решение отказаться от использования форм авторизации Keycloak и реализовать собственный API авторизации, делегировав серверу авторизации лишь задачи генерации и валидации токенов.
 
\section{Разработка клиентской части}

\section{Вывод}